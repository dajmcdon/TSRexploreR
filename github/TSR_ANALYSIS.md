
# TSR Analysis

Most genes tend to have more than one TSS, and these TSSs are usually clustered together into Transcription Start Regions (TSSs).
The position of a TSR can evidence the existance of a promoter and gene isoform,
and TSR shape features have been associated with certain gene classes.

tsrexplorer provides tools to explore and visualize TSRs.

## Preparing Data

This example will use a set of *S. cerevisiae* TSRs collected using the STRIPE-seq method.
There have been many great methods and R libraries developed for clustering TSSs,
including TSRchitect, CAGEr, and ADAPT-CAGE.
For this vignette, TSSs were clustered using TSRchitect with the parameters of minimum distance being 40 bp,
and read count threshold being 3.
TSRs were formatted as a named list of GRanges for further analysis.

```
library("tsrexplorer")

TSRs <- system.file("extdata", "S288C_TSRs.RDS", package = "tsrexplorer")
TSRs <- readRDS(TSRs)

# Keep only the 3 WT samples for now.
TSRs <- names(TSRs) %>%
	stringr::str_detect("WT") %>%
	purrr::keep(TSRs, .)

exp <- tsr_explorer(TSRs = TSRs)
```

## Processing of TSRs

After the TSRs are loaded into the tsrexplorer object,
there are a few processing steps to go through to get the data ready for analysis.
These steps include converting the TSRs into a 'RangedSummarizedExperiment',
CPM normalizing the TSRs, and then marking the dominant TSR.

### TSS Data Structure

The first step is to convert the TSRs into a 'RangedSummarizedExperiment'.
This object type is a convenient container that stores range, count, and sample information.

```
exp <- format_counts(exp, data_type = "tsr")
```

### CPM Normalization

The next step is to Counts Per Million (CPM) normalize the TSRs and store them as an additional assay with the original counts.
This step is optional, and if the counts you inputed were normalized already this step can safely be skipped.

```
exp <- cpm_normalize(exp, data_type = "tsr")
```

### Annotating TSRs

After formatting the counts and optionally CPM normalizing them, the TSRs will be annotated relative to known features.
This function takes either the path and file name of a 'GTF' or 'GFF' file, or a 'TxDb' package from bioconductor.
The annotation information will be added onto the range of the 'RangedSummarizedExperiment'.
The example below uses a 'GTF' file from Ensembl (R64-1-1 Release 99),
and will annotate each TSR to the closest transcript.

```
annotation <- system.file("extdata", "S288C_Annotation.gtf", package = "tsrexplorer")

exp <- annotate_features(
        exp, annotation_data = annotation,
        data_type = "tsr", feature_type = "transcript"
)
```

### Feature Counting

Now that the TSRs are annotated relative to known features, an RNA-seq like summary of counts per feature can be generated.
TSRs that are upstream of the defined promoter region, or downstream of the last exon are ignored.
The feature counts can also be optionally CPM normalized as well.

```
exp <- count_features(exp, data_type = "tsr")
exp <- cpm_normalize(exp, data_type = "tsr_features")
```

### Marking Dominant TSRs

For the last processing step, the TSR with the highest score is marked for each feature.
Similar to the feature counting step above, TSRs that are upstream of the defined promoter region,
or downstream of the last exon are ignored.
If there are multiple TSRs with the same max score, all of those TSRs are considered.

It is sometimes interesting to look at dominant TSRs because this subset likely represents transcription from the dominant
promoter and first exon of a gene.

```
exp <- mark_dominant(exp, data_type = "tsr")
```

## TSR Correlation

Finding the correlation between samples can be informative of both sequencing efficacy,
and to also get a cursory understanding about the differences between different samples.

### TMM Normalization

For correlation analysis, tsrexploreR uses 'TMM' normalization from the edgeR library.
This method was designed to make comparison *between* samples more efficacious.

```
exp <- tmm_normalize(exp, data_type = "tsr")
```

### Correlation Matrix Plots

After 'TMM' normalizing between the samples, various correlation plots can be generated by tsrexplorer.
An example is shown here, in which half the plot is a scatter plot, and the other half a heatmap.

```
p <- plot_correlation(exp, data_type = "tsr", font_size = 2, pt_size = 0.4) +
        ggplot2::theme_bw() +
        ggplot2::theme(text = element_text(size = 3), panel.grid = element_blank())

ggsave("tsr_correlation.png", plot = p, device = "png", type = "cairo", height = 2, width = 2)
```
![tsr_corr_plot](../inst/images/tsr_correlation.png)

## TSR Genomic Distribution

As part of the TSR processing steps, TSRs were annotated relative to known features.
This information can be used to explore the distribution of TSRs throughout the genome,
as well as information on detected features.

### Genomic Distribution Plot

A stacked bar plot can be generated to showcase the fractional distribution of TSRs relative to features.

```
tsr_distribution <- genomic_distribution(exp, data_type = "tsr", threshold = 3)

p <- plot_genomic_distribution(tsr_distribution) +
        ggplot2::theme(text = element_text(size = 4), legend.key.size = unit(0.3, "cm"))

ggsave("tsr_genomic_distribution.png", plot = p, device = "png", type = "cairo", height = 1, width = 2.5)
```
![tsr_genomic_distribution](../inst/images/tsr_genomic_distribution.png)

### Feature Detection Plot

The number of genes, and fraction of genes with a promoter proximal TSSs can be made into a stacked bar plot.

```
features <- detect_features(exp, data_type = "tsr")

p <- plot_detected_features(features) +
	ggplot2::theme(text = element_text(size = 3), legend.key.size = unit(0.3, "cm"))

ggsave("tsr_feature_plot.png", plot = p, device = "png", type = "cairo", height = 1, width = 1.75)
```

![tsr_feature_plot](../inst/images/tsr_feature_plot.png)

### Average Plots

Another useful plot type for TSRs are average plots centered around annotated TSSs.
The current yeast genome annotation does not contain any information on UTRs,
thus the average plot is centered on annotated start codons.
Because of this one would expect the average plot to be slightly upstream of the start codon center point.
Most other organisms have UTRs in their genome annotation,
with the UTR length being the furthest TSS detected from the start codon.
This would then result in average plots that are expected to be centered and slightly downstream from the annotated TSS center.

```
p <- plot_average(exp, data_type = "tsr", ncol = 3) +
        ggplot2::theme(text = element_text(size = 4))

ggsave("tsr_average_plot.png", plot = p, device = "png", type = "cairo", height = 1, width = 2)
```

![tsr_average_plot](../inst/images/tsr_average_plot.png)

### Heatmaps

While an average plot may give a general overview of TSRs relative to annotated start codons or TSSs,
it may sometimes be appropriate to generate a heatmap with TSR positions for all features displayed.

```
count_matrix <- tsr_heatmap_matrix(exp, threshold = 3, upstream = 500, downstream = 500)

p <- plot_heatmap(count_matrix, ncol = 3, background_color = "white") +
	ggplot2::theme(text = element_text(size = 4), legend.key.size = unit(0.3, "cm"))

ggsave("tsr_heatmap.png", plot = p, device = "png", type = "cairo", height = 2, width = 4)
```

![tsr_heatmap](../inst/images/tsr_heatmap.png)

## Gene Tracks

Vieweing TSSs and/or TSRs in gene tracks can be useful for a variety of reason.
It can make obvious which 5' isoforms of a transcript are expressed,
hint at potential misannotation of genes, uncover 5' UTR structure, and other various goodies.

A convenient function to generate gene tracks for TSSs and/or TSRs is included in tsrexplorer.
Tracks can be created based on a gene/transcript name, or genomic coordinates.
Additionally, if tracks are generated based on genes/transcripts, the promoter region only can be optionally displayed.

```
annotation <- system.file("extdata", "S288C_Annotation.gtf", package = "tsrexplorer")

png("tsr_tracks.png", units = "in", res = 300, height = 0.5, width = 4, type = "cairo")
gene_tracks(experiment, annotation, feature_name = "YAL012W", tss_samples = NA, track_colors = viridis::viridis(3))
dev.off()
```

![tsr_tracks](../inst/images/tsr_tracks.png)
