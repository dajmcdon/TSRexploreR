
#' TSS Heatmap Count Matrix
#'
#' Generate count matrix to make TSS heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @importFrom dplyr select filter group_by pull mutate_if rename
#' @importFrom magrittr %>%
#' @importFrom tidyr spread gather complete
#' @importFrom forcats fct_reorder
#' 
#' @param experiment tsrexplorer object with annotated TSSs
#' @param samples Either 'all' or name of samples to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param threshold Reads required per TSS
#' @param anno_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @export
#' @rdname tss_heatmap_matrix-function

tss_heatmap_matrix <- function(
	experiment,
	samples = "all",
	upstream = 1000,
	downstream = 1000,
	threshold = 1,
	anno_type = c("transcriptId", "geneId")
) {
	## Grab requested samples.
	if (samples == "all") samples <- names(experiment@experiment$TSSs)
	
	## Start preparing data for plotting.
	annotated_tss <- experiment@annotated$TSSs[samples] %>%
		bind_rows(.id = "sample") %>%
		rename(feature = anno_type) %>%
		filter(
			score >= threshold,
			between(distanceToTSS, -upstream, downstream)
		) %>%
		select(sample, feature, distanceToTSS, score) %>%
		mutate(feature = factor(feature))

	## Get order of genes for heatmap (mean accross samples).
	feature_order <- annotated_tss %>%
		mutate(feature = factor(feature)) %>%
		group_by(feature) %>%
		summarize(total_sum = sum(score)) %>%
		mutate(feature = fct_reorder(feature, desc(total_sum))) %>%
		pull(feature) %>%
		levels

	## Generate count matrix
	tss_matrix <- annotated_tss %>%
		complete(
			sample,
			feature = feature_order,
			distanceToTSS = -upstream:downstream,
			fill = list(score = 0)
		) %>%
		mutate(
			log2_score = log2(score + 1),
			feature = factor(feature, levels = feature_order)
		) %>%
		rename(position = distanceToTSS)

	return(tss_matrix)
}

#' Plot Heatmap
#'
#' Plot heatmap from count matrix generated by tss_heatmap_matrix or tsr_heatmap_matrix
#'
#' @import tibble
#' @import ggplot2
#' @importFrom dplyr mutate case_when desc
#' @importFrom tidyr gather
#' @importFrom forcats fct_rev
#' @importFrom magrittr %>%
#'
#' @param heatmap_matrix TSS or TSR heatmap matrix from tss_heatmap_matrix ot tsr_heatmap_matrix
#' @param max_value Max log2 value to truncate heatmap color
#' @param ncol Number of columns when plotting multiple samples
#'
#' @return ggplot2 object of TSS heatmap
#'
#' @export
#' @rdname plot_heatmap-function

plot_heatmap <- function(heatmap_matrix, max_value = 5, ncol = 1) {
	
	## Set values above max_value to max_value.
	heatmap_matrix <- heatmap_matrix %>%
		mutate(
			log2_score = case_when(
				log2_score <= max_value ~ log2_score,
				log2_score > max_value ~ max_value
			)
		)

	## Generate heatmap.
	p <- ggplot(heatmap_matrix, aes(x = position, y = fct_rev(feature), fill = log2_score, color = log2_score)) +
		geom_tile() +
		theme_minimal() +
		theme(
			axis.text.y = element_blank(),
			panel.grid = element_blank()
		) +
		scale_fill_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		) +
		scale_color_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		) +
		labs(
			fill = "log2(Score + 1)",
			x = "Position",
			y = "Feature"
		) +
		facet_wrap(~ sample, ncol = ncol)

	return(p)
}

#' TSR Heatmap Count Matrix
#'
#' Generate count matrix to make TSR heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @importFrom dplyr select mutate case_when bind_rows filter between group_by ungroup summarize
#' @importFrom magrittr %>%
#' @importFrom tidyr spread complete
#' @importFrom purrr pmap
#' 
#' @param experiment tsrexplorer object with annotated TSRs
#' @param sample Name of sample to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param feature_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @export
#' @rdname tsr_heatmap_matrix-function

tsr_heatmap_matrix <- function(
	experiment,
	samples = "all",
	upstream = 1000,
	downstream = 1000,
	feature_type = c("transcriptId", "geneId")
) {
	
	## Pull samples out.
	if (samples == "all") samples <- names(experiment@annotated$TSRs)

	## Prepare data to be made into count matrix
	annotated_tsr <- experiment@annotated$TSR[samples] %>%
		bind_rows(.id = "sample") %>%
		rename(
			feature = feature_type,
			score = nTAGs
		) %>%
		select(
			sample, strand, start, end, feature,
			geneStart, geneEnd, score
		) %>%
		mutate(
			startDist = case_when(
				strand == "+" ~ start - geneStart,
				strand == "-" ~ -(end - geneEnd)
			),
			endDist = case_when(
				strand == "+" ~ end - geneStart,
				strand == "-" ~ -(start - geneEnd)
			)
		) %>%
		select(sample, startDist, endDist, score, feature)

	## Get order of features based on sum of TSR scores.
	feature_order <- annotated_tsr %>%
		mutate(feature = factor(feature)) %>%
		group_by(feature) %>%
		summarize(total_sum = sum(score)) %>%
		mutate(feature = fct_reorder(feature, desc(total_sum))) %>%
		pull(feature) %>%
		levels

	## Put TSR score for entire range of TSR.
	annotated_tsr <- annotated_tsr %>%
		pmap(function(sample, startDist, endDist, score, feature) {
			tibble(
				sample = sample,
				position = seq(startDist, endDist, 1),
				score = score,
				feature = feature
			)
		}) %>%
		bind_rows %>%
		filter(between(position, -upstream, downstream)) %>%
		mutate(log2_score = log2(score + 1)) %>%
		complete(
			sample,
			feature = feature_order,
			position = -upstream:downstream,
			fill = list(score = 0, log2_score = 0)
		) %>%
		mutate(feature = factor(feature, levels = feature_order))

	return(annotated_tsr)
}
