
#' TSS Heatmap Count Matrix
#'
#' Generate count matrix to make TSS heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @importFrom dplyr select filter group_by pull mutate_if rename
#' @importFrom magrittr %>%
#' @importFrom tidyr spread gather complete
#' 
#' @param experiment tsrexplorer object with annotated TSSs
#' @param sample Name of sample to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param threshold Reads required per TSS
#' @param anno_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @export
#' @rdname tss_count_matrix-function

tss_count_matrix <- function(
	experiment, sample, upstream = 1000,
	downstream = 1000, threshold = 1,
	anno_type = c("transcriptId", "geneId")
) {
	## Prepare data to be made into count matrix
	annotated_tss <- experiment@annotated$TSSs[[sample]] %>%
		select(anno_type, distanceToTSS, score) %>%
		filter(
			distanceToTSS >= -upstream & distanceToTSS <= downstream,
			score >= threshold
		)
	
	if (anno_type == "geneId") {
		annotated_tss <- annotated_tss %>%
			complete(geneId, distanceToTSS = -upstream:downstream, fill = list(score = 0)) %>%
			spread(key = distanceToTSS, value = score) %>%
			mutate_if(is.numeric, ~log2(. + 1)) %>%
			rename("featureId" = geneId)
	} else {
                annotated_tss <- annotated_tss %>%
                        complete(transcriptId, distanceToTSS = -upstream:downstream, fill = list(score = 0)) %>%
                        spread(key = distanceToTSS, value = score) %>%
                        mutate_if(is.numeric, ~log2(. + 1)) %>%
			rename("featureId" = transcriptId)
	}

	return(annotated_tss)
}

#' Plot TSS Heatmap
#'
#' Plot TSS heatmap from count matrix generated by tss_count_matrix
#'
#' @import tibble
#' @import ggplot2
#' @importFrom dplyr transmute arrange pull mutate case_when desc
#' @importFrom tidyr gather
#' @importFrom forcats fct_rev
#' @importFrom magrittr %>%
#'
#' @param tss_count_matrix TSS count matrix from tss_count_matrix
#' @param max_value Max log2 value to truncate heatmap color
#'
#' @return ggplot2 object of TSS heatmap
#'
#' @export
#' @rdname plot_tss_heatmap-function

plot_tss_heatmap <- function(tss_count_matrix, max_value=5) {
	## Order genes by sum of TSS counts
	feature_order <- tss_count_matrix %>%
		transmute(featureId = featureId, rowsums=rowSums(select(., 2:ncol(.)))) %>% 
		arrange(desc(rowsums)) %>%
		pull(featureId)

	tss_count_matrix <- mutate(tss_count_matrix, featureId = factor(featureId, levels = feature_order))

	## Prepare data for plotting
	tss_count_matrix <- tss_count_matrix %>%
		gather(key="position", value="log2_score", -featureId) %>%
		mutate(
			position = as.integer(position),
			log2_score = case_when(
				log2_score <= max_value ~ log2_score,
				log2_score > max_value ~ max_value
			)
		)

	## Generate TSS heatmap
	p <- ggplot(tss_count_matrix, aes(x = position, y = fct_rev(featureId), fill = log2_score, color = log2_score)) +
		geom_tile() +
		theme_minimal() +
		theme(
			axis.text.y = element_blank(),
			panel.grid = element_blank()
		) +
		scale_fill_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		) +
		scale_color_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		)
		geom_vline(xintercept=0, lty=2, color="white") +
		labs(
			fill = "log2(Score + 1)",
			x = "Position",
			y = "Feature"
		)

	return(p)
}

#' TSR Heatmap Count Matrix
#'
#' Generate count matrix to make TSR heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @importFrom dplyr select mutate case_when bind_rows filter between group_by ungroup summarize
#' @importFrom magrittr %>%
#' @importFrom tidyr spread complete
#' @importFrom purrr pmap
#' 
#' @param experiment tsrexplorer object with annotated TSRs
#' @param sample Name of sample to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param feature_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @export
#' @rdname tsr_count_matrix-function

tsr_count_matrix <- function(
	experiment, sample,
	upstream = 1000, downstream = 1000,
	feature_type = c("transcriptId", "geneId")
) {
	## Prepare data to be made into count matrix
	annotated_tsr <- experiment@annotated$TSR[[sample]] %>%
		select(
			strand, start, end, geneId, transcriptId,
			geneStart, geneEnd, nTAGs
		) %>%
		mutate(
			startDist = case_when(
				strand == "+" ~ start - geneStart,
				strand == "-" ~ -(end - geneEnd)
			),
			endDist = case_when(
				strand == "+" ~ end - geneStart,
				strand == "-" ~ -(start - geneEnd)
			)
		) %>%
		select(startDist, endDist, nTAGs, geneId, transcriptId)

	if (feature_type == "transcriptId") {
		annotated_tsr <- annotated_tsr %>%
			pmap(function(startDist, endDist, nTAGs, transcriptId, geneId) {
				tibble(
					position = seq(startDist, endDist, 1),
					score = nTAGs,
					feature = transcriptId
				)
			}) %>%
			bind_rows
	} else {
		annotated_tsr <- annotated_tsr %>%
			pmap(function(startDist, endDist, nTAGs, transcriptId, geneId) {
				tibble(
					position = seq(startDist, endDist, 1),
					score = nTAGs,
					feature = geneId
				)
			}) %>%
			bind_rows()
	}

	annotated_tsr <- annotated_tsr %>%
		filter(between(position, -upstream, downstream)) %>%
		complete(feature, position = -upstream:downstream, fill = list(score = 0)) %>%
		group_by(feature, position) %>%
		summarize(score = sum(score)) %>%
		ungroup %>%
		mutate(log2_score = log2(score + 1)) %>%
		select(-score) %>%
		spread(key = position, value = log2_score)

	return(annotated_tsr)
}

#' Plot TSR Heatmap
#'
#' Plot TSR heatmap from count matrix generated by tsr_count_matrix
#'
#' @import tibble
#' @import ggplot2
#' @importFrom dplyr transmute arrange pull mutate case_when desc
#' @importFrom tidyr gather
#' @importFrom forcats fct_rev
#' @importFrom magrittr %>%
#'
#' @param tsr_count_matrix TSS count matrix from tss_count_matrix
#' @param max_value Max log2 value to truncate heatmap color
#'
#' @return ggplot2 object of TSS heatmap
#'
#' @export
#' @rdname plot_tsr_heatmap-function

plot_tsr_heatmap <- function(tsr_count_matrix, max_value = 8) {
	## order features by sum of TSR counts
	feature_order <- tsr_count_matrix %>%
		transmute(feature = feature, rowsums=rowSums(select(., 2:ncol(.)))) %>% 
		arrange(desc(rowsums)) %>%
		pull(feature)

	tsr_count_matrix <- mutate(tsr_count_matrix, feature = factor(feature, levels = feature_order))

	## Prepare data for plotting
	tsr_count_matrix <- tsr_count_matrix %>%
		gather(key="position", value="log2_score", -feature) %>%
		mutate(
			position = as.integer(position),
			log2_score = case_when(
				log2_score <= max_value ~ log2_score,
				log2_score > max_value ~ max_value
			)
		)
	
	## Plot TSR heatmap
	p <- ggplot(tsr_count_matrix, aes(x = position, y = fct_rev(feature), fill = log2_score, color = log2_score)) +
		geom_tile() +
		theme_minimal() +
		theme(
			axis.text.y = element_blank(),
			panel.grid = element_blank()
		) +
		scale_fill_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		) +
		scale_color_viridis_c(
			limits = c(0, max_value),
			breaks = c(0:max_value),
			labels = c(0:(max_value - 1), paste0(">", max_value)),
			name = "Log2(Score + 1)"
		) +
		geom_vline(xintercept=0, lty=2, color="white") +
		labs(
			fill = "log2(Score + 1)",
			x = "Position",
			y = "Feature"
		)

	return(p)
}
