
#' TSS Heatmap Count Matrix
#'
#' Generate count matrix to make TSS heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @import data.table
#' @importFrom S4Vectors DataFrame "metadata<-"
#' @importFrom SummarizedExperiment SummarizedExperiment rowRanges assay
#' @importFrom dplyr bind_rows dense_rank rename ntile filter between select mutate group_by summarize pull ungroup left_join desc
#' @importFrom magrittr %>% extract
#' @importFrom tidyr complete
#' @importFrom forcats fct_reorder
#' @importFrom purrr keep
#'
#' @param experiment tsrexplorer object with annotated TSSs
#' @param samples Either 'all' or name of samples to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param threshold Reads required per TSS
#' @param anno_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#' @param quantiles Number of quantiles to break data down into
#' @param use_cpm Whether to use the CPM normalized values or not
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @rdname tss_heatmap_matrix-function
#'
#' @export

tss_heatmap_matrix <- function(
	experiment,
	samples = "all",
	upstream = 1000,
	downstream = 1000,
	threshold = 1,
	anno_type = c("transcriptId", "geneId"),
	quantiles = NA,
	use_cpm = FALSE
) {
	## Grab requested samples.
	annotated_tss <- experiment %>%
		extract_counts("tss", samples, use_cpm) %>%	
		bind_rows(.id = "sample") %>%
		as.data.table

	setnames(annotated_tss, old = anno_type, new = "feature")
	annotated_tss <- annotated_tss[
		score >= threshold &
		dplyr::between(distanceToTSS, -upstream, downstream),
		.(sample, feature, distanceToTSS, score)
	]

	## Get order of genes for heatmap (mean across samples).
	annotated_tss <- annotated_tss[,
		.(sample, distanceToTSS, feature, score, feature_mean = mean(score)),
		by = feature
	][,
		.(sample, distanceToTSS, feature, score, rank = dense_rank(feature_mean))
	]

	## Add quantiles if specified.
	if (!is.na(quantiles)) {
		annotated_tss <- annotated_tss[,
			.(sample, distanceToTSS, feature, score, rank, ntile = ntile(rank, quantiles))
		]
	}

	## Format for plotting.
	if(!is.na(quantiles)) {
		annotated_tss <- annotated_tss[,
			.(sample, score, rank, ntile,
			distanceToTSS = factor(distanceToTSS, levels = seq(-upstream, downstream, 1)),
			feature = fct_reorder(factor(feature), rank))
		]
	} else {
		annotated_tss <- annotated_tss[,
			.(sample, score, rank,
			distanceToTSS = factor(distanceToTSS, levels = seq(-upstream, downstream, 1)),
			feature = fct_reorder(factor(feature), rank))
		]
	}

	## Return a DataFrame
	tss_df <- DataFrame(annotated_tss)
	metadata(tss_df)$threshold <- threshold
	metadata(tss_df)$quantiles <- quantiles
	metadata(tss_df)$use_cpm <- use_cpm
	metadata(tss_df)$promoter <- c(upstream, downstream)

	return(tss_df)
}

#' Plot Heatmap
#'
#' Plot heatmap from count matrix generated by tss_heatmap_matrix or tsr_heatmap_matrix
#'
#' @import tibble
#' @import data.table
#' @import ggplot2
#' @importFrom S4Vectors DataFrame metadata
#' @importFrom dplyr mutate case_when pull
#' @importFrom forcats fct_rev
#' @importFrom magrittr %>%
#'
#' @param heatmap_matrix TSS or TSR heatmap matrix from tss_heatmap_matrix ot tsr_heatmap_matrix
#' @param max_value Max log2 value to truncate heatmap color
#' @param ncol Number of columns when plotting multiple samples
#' @param ... Arguments passed to geom_tile
#'
#' @return ggplot2 object of TSS heatmap
#'
#' @rdname plot_heatmap-function
#'
#' @export

plot_heatmap <- function(heatmap_matrix, max_value = 5, ncol = 1, ...) {

	## Extract some info from the heatmap matrix.
	upstream <- metadata(heatmap_matrix)$promoter[1]
	downstream <- metadata(heatmap_matrix)$promoter[2]

	## Convert to data.table ,log2 transform scores, and then truncate values above 'max_value'.
	heatmap_mat <- as.data.table(heatmap_matrix)
	heatmap_mat <- heatmap_mat[,
		.(sample, score = ifelse(log2(score) > max_value, max_value, log2(score)),
		rank, distanceToTSS, feature)
	]

        ## plot
        p <- ggplot(heatmap_mat, aes(x = distanceToTSS, y = feature, fill = log2(score))) +
                geom_tile(...) +
                geom_vline(xintercept = upstream, color = "black", linetype = "dashed") +
                facet_grid(. ~ sample) +
                theme_minimal() +
                scale_x_discrete(
                        breaks = seq(-upstream, downstream, 1) %>% keep(~ (./100) %% 1 == 0),
                        labels = seq(-upstream, downstream, 1) %>% keep(~ (./100) %% 1 == 0)
                ) +
		scale_color_continuous (
			limits = c(0, max_value),
			breaks = seq(0, max_value, 1),
			labels = c(seq(0, max_value - 1, 1), paste0(">=", max_value)),
			name = "Log2(Score)"
		) +
                theme(
                        axis.text.x = element_text(angle = 45, hjust = 1),
                        panel.spacing = unit(1.5, "lines"),
                        axis.text.y = element_blank(),
                        axis.ticks.y = element_blank(),
                        panel.grid = element_blank(),
                        panel.background = element_rect(fill = "#F7F7F7", color = "black")
                ) +
		labs(x = "Position", y = "Feature")

	if (!is.na(metadata(heatmap_matrix)$quantiles)) {
		p <- p + facet_grid(fct_rev(factor(ntile)) ~ sample)
	} else {
		p <- p + facet_wrap(. ~ sample, ncol = ncol)
	}

	return(p)
}

#' TSR Heatmap Count Matrix
#'
#' Generate count matrix to make TSR heatmap
#'
#' @include tsrexplorer.R
#' @include annotate.R
#'
#' @import tibble
#' @import data.table
#' @importFrom SummarizedExperiment SummarizedExperiment rowRanges assay
#' @importFrom S4Vectors DataFrame "metadata<-"
#' @importFrom dplyr bind_rows rename select mutate case_when group_by summarize ungroup filter between left_join
#' @importFrom magrittr %>% extract
#' @importFrom tidyr complete
#' @importFrom purrr pmap
#' 
#' @param experiment tsrexplorer object with annotated TSRs
#' @param samples Either 'all' or names of samples to analyze
#' @param upstream Bases upstream to consider
#' @param downstream bases downstream to consider
#' @param feature_type Whether the heatmap is built on genes or transcripts ("geneId", "transcriptId")
#' @param quantiles Number of quantiles to split data into
#' @param threshold Reads required per TSR
#' @param use_cpm Whether to use CPM normalized or raw counts
#'
#' @return matrix of counts for each gene/transcript and position
#'
#' @rdname tsr_heatmap_matrix-function
#'
#' @export

tsr_heatmap_matrix <- function(
	experiment,
	samples = "all",
	upstream = 1000,
	downstream = 1000,
	feature_type = c("transcriptId", "geneId"),
	quantiles = NA,
	threshold = 1,
	use_cpm = FALSE
) {
	
	## Pull samples out.
	annotated_tsr <- experiment %>%
		extract_counts("tsr", samples, use_cpm) %>%
		bind_rows(.id = "sample") %>%
		as.data.table

	## Start preparing data for plotting.
	setnames(annotated_tsr, old = feature_type, new = "feature")
	annotated_tsr <- annotated_tsr[
		score >= threshold,
		.(sample, strand, start, end, feature, geneStart, geneEnd, score,
		startDist = ifelse(strand == "+", start - geneStart, -(end - geneEnd)),
		endDist = ifelse(strand == "+", end - geneStart, -(start - geneEnd)))
	][,
		.(sample, strand, startDist, endDist, score, feature, tsr_id = seq_len(.N))
	]

        ## Get order of genes for heatmap (mean across samples).
	annotated_tsr <- annotated_tsr[,
		.(sample, strand, startDist, endDist, feature, score, tsr_id, feature_mean = mean(score)),
		by = feature
	][,
		.(sample, strand, startDist, endDist, feature, score, tsr_id, rank = dense_rank(feature_mean))
	]

        ## Put TSR score for entire range of TSR.
        annotated_tsr <- annotated_tsr[,
                .(sample, feature, score, rank, distanceToTSS = seq(as.numeric(startDist), as.numeric(endDist), 1)),
                by = tsr_id
        ][
		dplyr::between(distanceToTSS, -upstream, downstream),
		.(sample, feature, score, rank, distanceToTSS)
	]

	## Add quantiles if specified.
	if (!is.na(quantiles)) {
		annotated_tsr <- annotated_tsr[,
			.(sample, feature, score, distanceToTSS, rank, ntile = ntile(rank, quantile))
		]
	}

        ## Format for plotting.
        if(!is.na(quantiles)) {
                annotated_tsr <- annotated_tsr[,
                        .(sample, score, rank, ntile,
                        distanceToTSS = factor(distanceToTSS, levels = seq(-upstream, downstream, 1)),
                        feature = fct_reorder(factor(feature), rank))
                ]
        } else {
                annotated_tsr <- annotated_tsr[,
                        .(sample, score, rank,
                        distanceToTSS = factor(distanceToTSS, levels = seq(-upstream, downstream, 1)),
                        feature = fct_reorder(factor(feature), rank))
                ]
        }

	## Return DataFrame
	tsr_df <- DataFrame(annotated_tsr)
	metadata(tsr_df)$threshold <- threshold
	metadata(tsr_df)$quantiles <- quantiles
	metadata(tsr_df)$use_cpm <- use_cpm
	metadata(tsr_df)$promoter <- c(upstream, downstream)

	return(tsr_df)
}
