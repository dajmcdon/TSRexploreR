
#' Generate Correlation Matrix
#'
#' Calculate a correlation matrix to assess between-sample concordance of TSSs or TSRs
#'
#' @param experiment tsrexplorer object with TMM-normalized counts
#' @param data_type Whether to make scatter plots from TSS, TSR, or RNA-seq & 5' data
#' @param samples Either 'all' or the names of the samples to plot
#' @param correlation_metric Whether to use Spearman or Pearson correlation
#'
#' @return Correlation matrix
#'
#' @rdname find_correlation-function
#'
#' @export

find_correlation <- function(
  experiment,
  data_type = c("tss", "tsr", "features"),
  samples = "all",
  correlation_metric = "pearson"
) {

  ## Select appropriate data.
  normalized_counts <- switch(
    data_type,
    "tss"=assay(experiment@correlation$TSSs$tmm, "tmm"),
    "tsr"=assay(experiment@correlation$TSRs$tmm, "tmm"),
    "features"=assay(experiment@correlation$features$tmm, "tmm")
  )

  type_color <- switch(
    type_color,
    "tss"="#431352",
    "tsr"="#34698c",
    "features"="#29AF7FFF"
  )

  ## Select all samples if "all" specified.
  if (samples == "all") samples <- colnames(normalized_counts)
  normalized_counts <- normalized_counts[, samples]

  ## Make correlation matrix.
  correlation <- normalized_counts %>%
    .[, samples] %>%
    cor(method = correlation_metric) %>%
    as_tibble(.name_repair = "unique", rownames = "sample_1") %>%
    pivot_longer(!sample_1, "sample_2", "cor")

  ## Place correlation values into proper slot.
  if (data_type == "tss") {
    experiment@correlation$TSSs$cor_matrix <- correlation
  } else if (data_type == "tsr") {
    experiment@correlation$TSRs$cor_matrix <- correlation
  } else {
    experiment@correlation$features$cor_matrix <- correlation
  }

  return(experiment)    
}

#' Plot Sample Correlation
#'
#' Heatmaps and/or scatter plots to explore replicate concordance of TSSs or TSRs.
#'
#' @importFrom GGally ggpairs
#' @importFrom ComplexHeatmap Heatmap
#' @importFrom circlize colorRamp2 
#' @importFrom viridis viridis
#' @importFrom grid gpar
#'
#' @param experiment tsrexplorer object with TMM normalized counts
#' @param data_type Whether to make scatter plots from TSS, TSR, or RNA-seq & 5' data
#' @param samples Either 'all' or the names of the samples to plot
#' @param correlation_plot Whether to make a correlation 'heatmap', 'scatter', 'combined', 
#'   or 'hierarchical' plot
#' @param correlation_metric Whether to use Spearman or Pearson correlation
#' @param log2_transform Should the TMM values be log2+1 transformed prior to plotting?
#' @param font_size The font size for the heatmap tiles
#' @param pt_size Point size for the scatter plots
#' @param ... Additional arguments passed to ComplexHeatmap::Heatmap or GGally::ggpairs
#'
#' @details
#' Correlation plots are a good way to assess the similarity of samples.
#' This can be useful to compare replicate concordance and for the initial assessment of
#'   the difference between samples from different conditions or treatments.
#' This function generates various plots using a previously TMM-normalized count matrix.
#'
#' 'correlation_metric' allows the specification of pearson or spearman correlation
#'   to be calculated between samples.
#' Pearson correlation is recommended for samples from the same technology,
#'   such as RNA-seq, due to the expectation of a roughly linear relationship between 
#'   the magnitudes of values for each feature.   
#' Spearmans correlation is recommended for samples from different technologies,
#'   such as RNA-seq vs. STRIPE-seq, due to the expectation of a roughly linear
#'   relationship between the ranks, rather than the specific values, of each feature.
#'
#' 'correlation_plot' specifies the type of plot to be generated by the function.
#' 'heatmap', 'scatter', and 'combined' plots are generated by the ggpairs plotting
#'   function of the GGally library.
#' The 'hierarchical' plot is generated using the Heatmap function of ComplexHeatmap.
#'
#' 'log2_transform' lets you specify whether you want the data to be log2 transformed
#'   prior to plotting.
#' Note that the transformation is done after the correlation metric is calculated,
#'   and is only meant to facilitate  visualization of the results.
#'
#' @return ggplot2 object of correlation plot
#'
#' @examples
#' TSSs <- system.file("extdata", "S288C_TSSs.RDS", package = "tsrexplorer")
#' TSSs <- readRDS(TSSs)
#' tsre_exp <- tsr_explorer(TSSs)
#' tsre_exp <- format_counts(tsre_exp, data_type = "tss")
#' tsre_exp <- count_matrix(tsre_exp, data_type = "tss")
#' tsre_exp <- tmm_normalize(tsre_exp, data_type = "tss")
#' plot_correlation(tsre_exp, data_type = "tss")
#'
#' @seealso \code{\link{count_matrix}} to generate the count matrices.
#'   \code{\link{tmm_normalize}} to TMM normalize the matrices.
#'
#' @rdname plot_correlation-function
#' @export

plot_correlation <- function(
  experiment,
  data_type = c("tss", "tsr", "tss_features", "tsr_features"),
  samples = "all",
  correlation_plot = "combined",
  correlation_metric = "pearson",
  log2_transform = TRUE,
  font_size = 4,
  pt_size = 0.5,
  ...
) {

  ## Check inputs.
  if (!is(experiment, "tsr_explorer")) stop("experiment must be a tsrexplorer object")
  data_type <- match.arg(data_type, c("tss", "tsr", "tss_features", "tsr_features"))
  if (!is(samples, "character")) stop("samples must be a character vector")
  correlation_plot <- match.arg(correlation_plot, c("heatmap", "scatter", "combined", "hierarchical"))
  correlation_metric <- match.arg(correlation_metric, c("pearson", "spearman"))
  if (!is(log2_transform, "logical")) stop("log2_transform must be logical")
  if(!is(font_size, "numeric") | !is(pt_size, "numeric")) {
    stop("font_size and pt_size must be positive numbers")
  }
  if (!(font_size >= 0) | !(pt_size >= 0)) stop("font_size and point_size must be positive numbers")
  
  ## Get data from proper slot.
  normalized_counts <- experiment %>%
    extract_matrix(data_type, samples) %>%
    assay("tmm")
  
  sample_names <- colnames(normalized_counts)

  ## Define default color palette.
  color_palette <- switch(
    data_type,
    "tss" = "#431352",
    "tsr" = "#34698c",
    "tss_features" = "#29AF7FFF",
    "tsr_features" = "#29AF7FFF"
  )

  ## Log2 + 1 transform data if indicated.
  pre_transformed <- as_tibble(normalized_counts, .name_repair = "unique")
  if (log2_transform) normalized_counts <- log2(normalized_counts + 1) %>% as_tibble(.name_repair = "unique")

  ## Make functions for scatter plot.

  # Create custom scatter plot format.
  custom_scatter <- function(data, mapping) {
    ggplot(data = data, mapping = mapping) +
      geom_point(size = pt_size, color = color_palette, stroke = 0) +
      geom_abline(intercept = 0, slope = 1, lty = 2)
  }

  # Create custom correlation heatmap format.
  custom_heatmap <- function(data, mapping) {
    sample_1 <- pre_transformed[ ,str_replace(mapping$x, "~", "")]
    sample_2 <- pre_transformed[ ,str_replace(mapping$y, "~", "")]

    correlation <- cor(sample_1, sample_2, method = correlation_metric) %>%
      round(3) %>%
      as_tibble(name_repair = "unique", rownames = "sample_1") %>%
      pivot_longer(!sample_1, "sample_2", "correlation")

    ggplot(correlation, aes(x = sample_1, y = sample_2)) +
      geom_tile(color = "white", aes(fill = correlation)) +
      geom_label(aes(label = correlation), label.size=NA, fill=NA, color = "black", size = font_size) +
      scale_fill_viridis_c(limits = c(0, 1))
  }

  ## Plot the correlation plot.   

  if (correlation_plot == "scatter") {
    p <- ggpairs(
      normalized_counts,
      columns = sample_names,
      upper = list(continuous = custom_scatter),
      lower = NULL,
      diag = NULL,
      ...
    )
  } else if (correlation_plot == "heatmap") {
    p <- ggpairs(
      normalized_counts,
      columns = sample_names,
      upper = list(continuous = custom_heatmap),
      lower = NULL,
      diag = NULL,
      ...
    )
  } else if (correlation_plot == "combined") {
    p <- ggpairs(
      normalized_counts,
      columns = sample_names,
      upper = list(continuous = custom_heatmap),
      lower = list(continuous = custom_scatter),
      ...
    )
  } else if (correlation_plot == "hierarchical") {
    corr_matrix <- pre_transformed %>%
      cor(method = correlation_metric)

    p <- Heatmap(
      corr_matrix,
      name = correlation_metric,
      row_names_gp = gpar(fontsize = font_size),
      column_names_gp = gpar(fontsize = font_size),
      heatmap_legend_param = list(
        title_gp = gpar(fontsize = font_size),
        labels_gp = gpar(fontsize = font_size),
        grid_height = unit(2, "mm"),
        grid_width = unit(3, "mm")
      ),
      ...
    )
  }

  return(p)
}
